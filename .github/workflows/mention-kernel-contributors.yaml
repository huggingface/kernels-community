name: Mention non-collaborator reviewers

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read
  pull-requests: write

jobs:
  mention:
    name: Comment mentions
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Mention reviewers based on changed paths
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const configPath = '.github/mention-rules.json';
            let rules;
            try {
              const raw = fs.readFileSync(configPath, 'utf8');
              rules = JSON.parse(raw);
            } catch (e) {
              core.warning(`No ${configPath} found or invalid JSON. Skipping mentions. Error: ${e.message}`);
              return;
            }

            const prNumber = context.payload.pull_request.number;

            // Get list of changed files in this PR
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              per_page: 100
            });

            const changed = files.map(f => f.filename);

            const normalize = (p) => p.replace(/^\/+/, '');
            const toPrefix = (key) => {
              // Treat keys as simple prefixes, supporting optional leading '/' and trailing '/**'
              let k = key;
              if (k.endsWith('/**')) k = k.slice(0, -3);
              return normalize(k);
            };

            const mentions = new Set();
            for (const [key, handles] of Object.entries(rules)) {
              const prefix = toPrefix(key);
              const matched = changed.some(fp => normalize(fp).startsWith(prefix));
              if (matched) {
                for (const h of handles) {
                  const handle = h.startsWith('@') ? h : `@${h}`;
                  mentions.add(handle);
                }
              }
            }

            if (mentions.size === 0) {
              core.info('No matching mention rules for this PR.');
              return;
            }

            const marker = '<!-- mention-non-collab-reviewers -->';
            const body = `${marker}\nRequesting input from community reviewers based on changed paths:\n\n${[...mentions].join(' ')}`;

            // Check for an existing bot comment with our marker
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100
            });
            const existing = comments.find(c => c.user && c.user.type === 'Bot' && c.body && c.body.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body
              });
              core.info('Updated existing mention comment.');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body
              });
              core.info('Created new mention comment.');
            }
